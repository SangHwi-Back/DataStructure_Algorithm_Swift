# Quicksort

comparison-based 알고리즘의 하나다. MergeSort 처럼 분할정복 방식을 사용한다. Quicksort 의 가장 중요한 점은 pivot 을 정하는 것이다. pivot 은 배열을 세 개의 부분으로 나누게 된다.

파티셔닝 전략은 pivot 을 어디로 잡느냐에 따라 나뉜다. 파티셔닝 전략을 효율적으로 수행하면 sorting 이 더욱 수월하다. pivot 은 배열의 중간 값이다. 정렬의 기준이 되는 값으로 해석될 수 있다.

[elements<pivot | pivot | pivo<elements] 

## Naive partitioning

1. 중간 인덱스 (([배열의 갯수] / 2), 짝수 개의 배열이라면 반올림한다) 의 값인 pivot 을 설정한다.

[12, 0, 3, 9, 2, 18, 8, 27, 1, 5, 8, -1, 21]
                     *

그리고 pivot 보다 작은 값을 뽑아내고, pivot 과 같은 값을 뽑아내고, pivot 보다 큰 값을 뽑아내어 3 부분으로 나눈다. 이를 partitioning 이라고 한다.
[0,3,2,1,5,-1] [8,8] [12,9,18,27,21]

2. 1의 과정을 반복해보자.

[0,-1] [1] [3,2,5] [8,8] [12,9] [18] [27,21]
[] [-1] [0] [1] [] [2] [3,5] [8,8] [9] [12] [18] [21] [27]
[] [-1] [0] [1] [] [2] [3] [5] [8,8] [9] [12] [18] [21] [27]


## Lomuto's partitioning

마지막 요소를 pivot 으로 정하는 방법이다. 기본 구현에서 세 개의 배열을 만들어 내는 것 보다 더 효율적이다.

1. 정렬하고 싶은 범위를 low, high 로 정의해서 넘겨준다. 
    - 범위의 마지막 요소를 pivot 으로 미리 불러온다.
    - 범위의 첫번째 인덱스를 i 로 정의한다.
2. high에 -1을 한 뒤 low 에서 high 까지 for-loop 를 실행한다.
    - for-loop 로 불러온 인덱스의 요소가 pivot 보다 적거나 같다면, for-loop 인덱스와 i 인덱스의 요소의 위치를 서로 바꾼다.
    - 이 과정을 실행했다면 i 는 1을 더해준다.
3. for-loop 종료 후 i 와 high 인덱스의 요소 위치를 바꾼다.
4. i 를 반환한다. i 는 인덱스이며 새로운 pivot 이 된다.
    - i 아래 요소들은 무조건 i 의 요소보다 작거나 같다.
    - i 포함 high 까지의 요소들은 무조건 i 의 요소보다 크다
    - high 부터 그 뒤의 요소들은 아직 비교하지 않았다.

### 시각화

> low 는 배열의 첫번째 인덱스인 0, high 는 마지막 인덱스인 12

[12, 0, 3, 9, 2, 21, 18, 27, 1, 5, 8, -1, 8]<br/>
 
pivot -> 8

> 12 <= 8. continue!

[12, 0, 3, 9, 2, 21, 18, 27, 1, 5, 8, -1, |  8]<br/>
low                                        <br/>
-i                                               <br/>
----j                                           <br/>

> 0 <== 8. i & j swap, i += 1, next for-loop!

[**0**,  **12**,  3, 9, 2, 21, 18, 27, 1, 5, 8, -1, |  8]<br/>
low                                         <br/>
-(+1)i                                          <br/>
-(next)-j                                     <br/>

> 3 <== 8. i & j swap, i += 1, next for-loop!

[0, **3**, **12**, 9, 2, 21, 18, 27, 1, 5, 8, -1, |  8]<br/>
low                                         <br/>
---(+1)i                                       <br/>
----(next)j                                    <br/>

> 계속 진행....

[ 0, 3, 2, 1, 5, 8, -1, 27, 9, 12, 21, 18, |  8  ]<br/>
low                                         <br/>
--------------------i<br/>

> 마지막 i & high swap

[ 0, 3, 2, 1, 5, 8, -1, **8**, 9, 12, 21, 18, |  **27**  ]<br/>
low                                         <br/>
-------------------i<br/>

## Hoare's partitioning

첫번째 요소를 pivot 으로 정하는 방법이다. 기본 구현에서 세 개의 배열을 만들어 내는 것 보다 더 효율적이다.

1. 정렬하고 싶은 범위를 low, high 로 정의해서 넘겨준다.
    - 범위의 첫번째 요소를 pivot 으로 미리 불러온다.
    - 범위의 첫번째 인덱스 이전 인덱스를 i, 범위의 마지막 인덱스 다음 인덱스를 j 로 지정한다.
2. i 의 요소가 pivot 보다 크고, j 의 요소가 pivot 작을 때 크면 두 요소의 위치를 바꾼다.
3. i 와 j 가 겹치면 (i < j) j 를 반환한다.
    - j 는 새로운 pivot 이 된다.

### 시각화

> low 는 배열의 첫번째 인덱스인 0, high 는 마지막 인덱스인 12

[  12, 0, 3, 9, 2, 21, 18, 27, 1, 5, 8, -1, 8   ]<br/>
--i---------------------------------j

pivot -> 12

> i 가 12 인덱스일 때 j 가 8 인덱스일 때 일 때, i 요소는 pivot 보다 크고, j 요소는 pivot 보다 작음. swap.

[  **8**, 0, 3, 9, 2, 21, 18, 27, 1, 5, 8, -1, **12**   ]<br/>
--i---------------------------------j

> i 가 21 인덱스일 때 j 가 -1 인덱스일 때 일 때, i 요소는 pivot 보다 크고, j 요소는 pivot 보다 작음. swap.

[  8, 0, 3, 9, 2, 21, 18, 27, 1, 5, 8, -1, 12   ]<br/>
---------------i-----------------j-----

[  8, 0, 3, 9, 2, **-1**, 18, 27, 1, 5, 8, **21**, 12   ]<br/>
---------------i-----------------j-----

> i 가 18 인덱스일 때 j 가 8 인덱스일 때 일 때, i 요소는 pivot 보다 크고, j 요소는 pivot 보다 작음. swap. i 가 27, j 가 5 를 가리킬 때도 마찬가지로 swap.

[  8, 0, 3, 9, 2, -1, 18, 27, 1, 5, 8, 2, 12   ]<br/>
------------------i----------j--------

[  8, 0, 3, 9, 2, -1, **8**, 27, 1, 5, **18**, 2, 12   ]<br/>
------------------i----------j--------

[  8, 0, 3, 9, 2, -1, 8, 27, 1, 5, 18, 2, 12   ]<br/>
--------------------i-----j-----------

[  8, 0, 3, 9, 2, -1, 8, **5**, 1, **27**, 18, 2, 12   ]<br/>
--------------------i-----j-----------

> 이제 i, j 를 이동시키면 요소 1의 인덱스에서 두 인덱스가 겹치게 되므로, j 가 마지막으로 가리키게 될 요소 1 의 인덱스를 새로운 pivot 으로 반환.

## 비효율적인 partitioning 전략

적절한 partitioning 전략에 따라 quicksort 의 성능이 바뀐다.

1. 중간 요소를 pivot
2. Lomuto. 마지막 요소를 pivot
3. Hoare, 첫번째 요소를 pivot

다음 중 어떤 전략이 문제가 될까?

다음의 예시가 있다.

[8,7,6,5,4,3,2,1]

Lomuto 알고리즘을 쓴다면 equal 부분(pivot)은 [1], less 부분은 [], greater 부분은 [7,6,5,4,3,2] 이 된다.

가장 이상적인 pivoting 은 less, greater 가 같은 양으로 나뉘는 것이다. 이미 정렬된 배열의 처음/마지막 요소를 pivoting 하는 것은 최악의 성능이 나오게 된다( O(n2) ).

median of three pivoting 전략은 중간에서 첫번째, 중간에서 마지막 요소를 pivot 으로 사용하는 것이다. 첫번째, 중간, 마지막 요소를 sorting 하고 중간 인덱스를 반환한다. 이를 통해 Lomuto's 전략을 효율적으로 수행할 수 있다.

## Dutch national flag partitioning

Lomuto's 와 Hoare's 알고리즘의 문제점은 중복처리로 인한 리소스 낭비를 잘 처리하지 못한다는 것이다.

Lomuto's 알고리즘은 less (pivot 보다 작은 요소들만 모인 왼쪽 배열) 배열이 중복되는 작업이 처리되는 것에 대한 대책이 없다. Hoare's 알고리즘은 모든 요소를 검사하기 때문에 중복처리로 인한 리소스 낭비가 더욱 심해질 수 있다.

수많은 중복 요소를 처리하는 데엔 Dutch national flag partitioning 이 효과적이다. 네덜란드 국기처럼 색이 다른 세 줄 (빨간색, 하얀색, 파란색) 처럼 서로 다른 세 개의 partition을 갖는다.

Dutch national flag partitioning 은 Partitioning Strategy(Lomuto's, Hoare's) 에 대해 독립적으로 작동한다.

1. pivot 으로 정할 인덱스를 미리 지정한다. 만약 Lomuto 를 따른다면 마지막, Hoare 를 따른다면 첫번째 인덱스일 것이다.
2. 정렬에 필요한 인덱스를 아래와 같이 정의한다.
    - pivot 보다 작은 요소로 이동시킬 smaller 인덱스를 변수에 저장한다. 최초 값은 정렬하려는 범위의 최소값이 된다. 이동이 진행되면 이 값은 1 씩 증가할 것이다.
    - smaller 와 같은 값으로 선언할 인덱스는 equal 이다. equal 은 계속 한칸씩 이동하면서 pivot 값과 비교해서 작을 경우, smaller 위치로 이동하기 위해 사용할 것이다.
    - equal 인덱스의 요소와 pivot 값을 비교했을 때 equal 인덱스의 요소가 더 클 경우 이동시킬 인덱스로 larger 인덱스를 선언한다.
3. equal 인덱스와 larger 인덱스가 서로 겹칠 때까지 작동하는 while-loop 를 선언한다.
    - equal 요소가 pivot 보다 작으면 smaller 위치 요소와 equal 위치 요소 자리를 바꾼다. smaller 와 equal 인덱스는 각각 1씩 증가한다.
    - equal 요소와 pivot 요소가 같을 경우는 skip. equal 요소만 1 증가한다.
    - equal 요소가 pivot 보다 클 경우 larger 위치 요소와 equal 위치 요소 자리를 바꾼다. larger 인덱스는 1 감소한다.

## 키 포인트

* naive partitioning 은 매 함수 실행마다 새로운 array 를 만든다. 비효율적인 면이 있다.
* Lomuto's partitioning 은 마지막 요소를 pivoting 한다.
* Hoare's partitioning 은 첫번째 요소를 pivoting 한다.
* 이상적인 pivoting 은 partitioning 을 고르게 하는 것이다.
* 잘못된 pivoting 은 높은 시간복잡도 (O(n2)) 를 야기한다.
* Median of three 는 pivot 을 중간에서 첫번째, 중간에서 마지막 요소로 잡는다.
* Dutch national flag partitioning 은 중복 요소를 효율적으로 정렬한다.
