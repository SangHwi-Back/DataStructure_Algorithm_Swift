# O(n2) Sorting Algorithsm

O(n2) 시간 복잡도는 좋은 시간복잡도라 할 수는 없다.   
하지만 이런 종류의 알고리즘은 이해하기 쉽고, 몇몇 상황에서는 확실히 유용하다.   
예) 공간 효율성이 높아서 추가적인 O(1) 메모리 공간만 있으면 된다.

여기서는 세 가지 정렬 알고리즘을 알아볼 것이다.

1. Bubble Sort
2. Selection Sort
3. Insertion Sort

이 정렬 알고리즘들은 comparion-base(비교 기반)의 알고리즘이다. 비교 연산을 얼마나 호출하느냐는 정렬 테크닉에 달렸다.

## Bubble Sort (시간복잡도 : O(n) ~ O(n2))

반복하여 근접한 값을 비교하고 필요할 시 교환하여 정렬하는 방식이다. 특정 세트의 값 중 큰 값은 "bubble up"하여 맨 마지막으로 이동하는 방식이다.

가장 큰 값만 마지막 요소로 만드는 것이 목표이기 때문에 한 번의 사이클 이상을 돌아야 할 수 있다.

### 예시

[9,4,10,3] 배열을 정렬한다.

1. 맨 처음 요소부터 시작하여 9와 4를 비교한다. 이 둘을 비교하면 순서가 뒤바뀌어야 하므로, [4,9,10,3] 이 되어야 한다.
2. 다음 인덱스로 이동하여 9와 10을 비교한다. 값을 비교했을 때 순서가 이상 없다.
3. 다음 인덱스로 이동하여 10과 3을 비교한다. 1번과 같이 둘을 바꾸서 [4,9,3,10]

여기까지가 1번 사이클이다. 대부분 1번 사이클로는 정렬이 되지 않는다.

이 사이클을 2번 더 반복해본다.

[4,9,3,10] -> [4,3,9,10] -> [3,4,9,10]

더 이상 Swap 이 일어나지 않을 때 모든 배열의 요소 정렬은 끝난다.

## Selection Sort (시간복잡도 : O(n) ~ O(n2))

Bubble Sort의 기본 아이디어를 사용하여 Bubble Sort의 사이클 중 맨 마지막만 Swap 을 실행한다.

### 예시

[9,4,10,3] 배열을 정렬한다.

각 사이클마다 Selection Sort 는 가장 작으면서 정렬되지 않은 값을 찾고 적절한 위치에 정렬한다.

1. 3 을 9 와 바꾼다.
2. 3 다음 가장 작은 값인 4 를 찾았으나 이미 적당한 위치에 있다.
3. 4 다음 가장 작은 값인 9 를 10과 바꾼다.


## Insertion Sort (시간복잡도 : O(n) ~ O(n2))

평균적으로 O(n2) 시간 복잡도를 가진 Insertion Sort 는 이미 정렬된 요소가 많을 수록 좋은 성능을 발휘한다.

Swift std 는 sort 알고리즘을 사용할 때 여러 알고리즘을 혼용하는데, 20개 이하의 Collection 에는 Insertion Sort 가 쓰인다.

### 예시

손에 놓인 카드들(Symbol은 같다고 가정)을 정렬하는 방식을 떠올리면 쉽다.

전체 요소를 1회 반복하며 각 요소들이 왼쪽에서 오른쪽으로 이동한다. 정렬이 완료될 때까지 반복은 계속된다.

1. [9,4,10,3] -> 0 인덱스 검사, 이전 요소 조회할 수 없으므로 현 위치 유지.
2. [4,9,10,3] -> 1 인덱스 검사, 이전 요소 9과 비교했을 때 현 위치 변경 필요하여 위치 변경.
3. [4,9,10,3] -> 2 인덱스 검사, 이전 요소 9와 비교했을 때 현 위치 유지.
4. [3,4,9,10] -> 3 인덱스 검사, 이전 요소 10과 비교했을 때 위치 변경. 2 인덱스 검사와 1인덱스 검사를 반복적으로 수행해도 모두 변경이 필요.

## Generalization(일반화)

Array 타입에 정렬 알고리즘을 일반화 해보자.

- Insertion Sort 는 shifting 이 발생할 때마다 역방향 순회를 한다. 여기서 Collection 은 BidirectionalCollection 타입이어야 한다.
- Bubble Sort / Selection Sort 는 Collection에서 정방향 순회를 하기 때문에 어떠한 Collection 에서도 가능하다.
- 모든 정렬상황에서 Collection 은 MutableCollection 이어야 한다. swap, shift 를 위해서이다.